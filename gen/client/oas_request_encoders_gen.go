// Code generated by ogen, DO NOT EDIT.

package client

import (
	"bytes"
	"mime"
	"mime/multipart"
	"net/http"
	"strings"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"

	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/uri"
)

func encodeAsteroidsMaildomainsCreateRequest(
	req AsteroidsMaildomainsCreateReq,
	r *http.Request,
) error {
	switch req := req.(type) {
	case *AsteroidsMaildomainsCreateApplicationJSON:
		const contentType = "application/json"
		e := new(jx.Encoder)
		{
			req.Encode(e)
		}
		encoded := e.Bytes()
		ht.SetBody(r, bytes.NewReader(encoded), contentType)
		return nil
	case *AsteroidsMaildomainsCreateApplicationXWwwFormUrlencoded:
		const contentType = "application/x-www-form-urlencoded"
		request := req

		q := uri.NewFormEncoder(map[string]string{})
		{
			// Encode "name" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "name",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				return e.EncodeValue(conv.StringToString(request.Name))
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		{
			// Encode "asteroid" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "asteroid",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				return e.EncodeValue(conv.StringToString(request.Asteroid))
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		encoded := q.Values().Encode()
		ht.SetBody(r, strings.NewReader(encoded), contentType)
		return nil
	case *MailDomainRequestMultipart:
		const contentType = "multipart/form-data"
		request := req

		q := uri.NewFormEncoder(map[string]string{})
		{
			// Encode "name" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "name",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				return e.EncodeValue(conv.StringToString(request.Name))
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		{
			// Encode "asteroid" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "asteroid",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				return e.EncodeValue(conv.StringToString(request.Asteroid))
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		body, boundary := ht.CreateMultipartBody(func(w *multipart.Writer) error {
			if err := q.WriteMultipart(w); err != nil {
				return errors.Wrap(err, "write multipart")
			}
			return nil
		})
		ht.SetCloserBody(r, body, mime.FormatMediaType(contentType, map[string]string{"boundary": boundary}))
		return nil
	default:
		return errors.Errorf("unexpected request type: %T", req)
	}
}

func encodeAsteroidsMaildomainsUsersCreateRequest(
	req AsteroidsMaildomainsUsersCreateReq,
	r *http.Request,
) error {
	switch req := req.(type) {
	case *AsteroidsMaildomainsUsersCreateApplicationJSON:
		const contentType = "application/json"
		e := new(jx.Encoder)
		{
			req.Encode(e)
		}
		encoded := e.Bytes()
		ht.SetBody(r, bytes.NewReader(encoded), contentType)
		return nil
	case *AsteroidsMaildomainsUsersCreateApplicationXWwwFormUrlencoded:
		const contentType = "application/x-www-form-urlencoded"
		request := req

		q := uri.NewFormEncoder(map[string]string{})
		{
			// Encode "name" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "name",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				return e.EncodeValue(conv.StringToString(request.Name))
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		{
			// Encode "password_hash" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "password_hash",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := request.PasswordHash.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		{
			// Encode "keep_forwards" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "keep_forwards",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := request.KeepForwards.Get(); ok {
					return e.EncodeValue(conv.BoolToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		{
			// Encode "is_sysmail" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "is_sysmail",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := request.IsSysmail.Get(); ok {
					return e.EncodeValue(conv.BoolToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		{
			// Encode "is_catchall" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "is_catchall",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := request.IsCatchall.Get(); ok {
					return e.EncodeValue(conv.BoolToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		encoded := q.Values().Encode()
		ht.SetBody(r, strings.NewReader(encoded), contentType)
		return nil
	case *MailUserRequestMultipart:
		const contentType = "multipart/form-data"
		request := req

		q := uri.NewFormEncoder(map[string]string{})
		{
			// Encode "name" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "name",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				return e.EncodeValue(conv.StringToString(request.Name))
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		{
			// Encode "password_hash" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "password_hash",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := request.PasswordHash.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		{
			// Encode "keep_forwards" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "keep_forwards",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := request.KeepForwards.Get(); ok {
					return e.EncodeValue(conv.BoolToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		{
			// Encode "is_sysmail" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "is_sysmail",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := request.IsSysmail.Get(); ok {
					return e.EncodeValue(conv.BoolToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		{
			// Encode "is_catchall" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "is_catchall",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := request.IsCatchall.Get(); ok {
					return e.EncodeValue(conv.BoolToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		body, boundary := ht.CreateMultipartBody(func(w *multipart.Writer) error {
			if err := q.WriteMultipart(w); err != nil {
				return errors.Wrap(err, "write multipart")
			}
			return nil
		})
		ht.SetCloserBody(r, body, mime.FormatMediaType(contentType, map[string]string{"boundary": boundary}))
		return nil
	default:
		return errors.Errorf("unexpected request type: %T", req)
	}
}

func encodeAsteroidsMaildomainsUsersForwardsCreateRequest(
	req AsteroidsMaildomainsUsersForwardsCreateReq,
	r *http.Request,
) error {
	switch req := req.(type) {
	case *AsteroidsMaildomainsUsersForwardsCreateApplicationJSON:
		const contentType = "application/json"
		e := new(jx.Encoder)
		{
			req.Encode(e)
		}
		encoded := e.Bytes()
		ht.SetBody(r, bytes.NewReader(encoded), contentType)
		return nil
	case *AsteroidsMaildomainsUsersForwardsCreateApplicationXWwwFormUrlencoded:
		const contentType = "application/x-www-form-urlencoded"
		request := req

		q := uri.NewFormEncoder(map[string]string{})
		{
			// Encode "user" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "user",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := request.User.Get(); ok {
					if unwrapped := string(val); true {
						return e.EncodeValue(conv.StringToString(unwrapped))
					}
					return nil
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		{
			// Encode "destination" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "destination",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				return e.EncodeValue(conv.StringToString(request.Destination))
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		encoded := q.Values().Encode()
		ht.SetBody(r, strings.NewReader(encoded), contentType)
		return nil
	case *MailForwardRequestMultipart:
		const contentType = "multipart/form-data"
		request := req

		q := uri.NewFormEncoder(map[string]string{})
		{
			// Encode "user" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "user",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := request.User.Get(); ok {
					if unwrapped := string(val); true {
						return e.EncodeValue(conv.StringToString(unwrapped))
					}
					return nil
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		{
			// Encode "destination" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "destination",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				return e.EncodeValue(conv.StringToString(request.Destination))
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		body, boundary := ht.CreateMultipartBody(func(w *multipart.Writer) error {
			if err := q.WriteMultipart(w); err != nil {
				return errors.Wrap(err, "write multipart")
			}
			return nil
		})
		ht.SetCloserBody(r, body, mime.FormatMediaType(contentType, map[string]string{"boundary": boundary}))
		return nil
	default:
		return errors.Errorf("unexpected request type: %T", req)
	}
}

func encodeAsteroidsMaildomainsUsersPatchRequest(
	req AsteroidsMaildomainsUsersPatchReq,
	r *http.Request,
) error {
	switch req := req.(type) {
	case *AsteroidsMaildomainsUsersPatchReqEmptyBody:
		// Empty body case.
		return nil
	case *AsteroidsMaildomainsUsersPatchApplicationJSON:
		const contentType = "application/json"
		e := new(jx.Encoder)
		{
			req.Encode(e)
		}
		encoded := e.Bytes()
		ht.SetBody(r, bytes.NewReader(encoded), contentType)
		return nil
	case *AsteroidsMaildomainsUsersPatchApplicationXWwwFormUrlencoded:
		const contentType = "application/x-www-form-urlencoded"
		request := req

		q := uri.NewFormEncoder(map[string]string{})
		{
			// Encode "password_hash" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "password_hash",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := request.PasswordHash.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		{
			// Encode "alias_of" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "alias_of",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := request.AliasOf.Get(); ok {
					if unwrapped := string(val); true {
						return e.EncodeValue(conv.StringToString(unwrapped))
					}
					return nil
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		{
			// Encode "keep_forwards" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "keep_forwards",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := request.KeepForwards.Get(); ok {
					return e.EncodeValue(conv.BoolToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		{
			// Encode "is_sysmail" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "is_sysmail",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := request.IsSysmail.Get(); ok {
					return e.EncodeValue(conv.BoolToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		{
			// Encode "is_catchall" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "is_catchall",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := request.IsCatchall.Get(); ok {
					return e.EncodeValue(conv.BoolToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		encoded := q.Values().Encode()
		ht.SetBody(r, strings.NewReader(encoded), contentType)
		return nil
	case *PatchedMailUserRequestMultipart:
		const contentType = "multipart/form-data"
		request := req

		q := uri.NewFormEncoder(map[string]string{})
		{
			// Encode "password_hash" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "password_hash",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := request.PasswordHash.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		{
			// Encode "alias_of" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "alias_of",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := request.AliasOf.Get(); ok {
					if unwrapped := string(val); true {
						return e.EncodeValue(conv.StringToString(unwrapped))
					}
					return nil
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		{
			// Encode "keep_forwards" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "keep_forwards",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := request.KeepForwards.Get(); ok {
					return e.EncodeValue(conv.BoolToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		{
			// Encode "is_sysmail" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "is_sysmail",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := request.IsSysmail.Get(); ok {
					return e.EncodeValue(conv.BoolToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		{
			// Encode "is_catchall" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "is_catchall",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := request.IsCatchall.Get(); ok {
					return e.EncodeValue(conv.BoolToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		body, boundary := ht.CreateMultipartBody(func(w *multipart.Writer) error {
			if err := q.WriteMultipart(w); err != nil {
				return errors.Wrap(err, "write multipart")
			}
			return nil
		})
		ht.SetCloserBody(r, body, mime.FormatMediaType(contentType, map[string]string{"boundary": boundary}))
		return nil
	default:
		return errors.Errorf("unexpected request type: %T", req)
	}
}

func encodeAsteroidsPatchRequest(
	req AsteroidsPatchReq,
	r *http.Request,
) error {
	switch req := req.(type) {
	case *AsteroidsPatchReqEmptyBody:
		// Empty body case.
		return nil
	case *AsteroidsPatchApplicationJSON:
		const contentType = "application/json"
		e := new(jx.Encoder)
		{
			req.Encode(e)
		}
		encoded := e.Bytes()
		ht.SetBody(r, bytes.NewReader(encoded), contentType)
		return nil
	case *AsteroidsPatchApplicationXWwwFormUrlencoded:
		const contentType = "application/x-www-form-urlencoded"
		request := req

		q := uri.NewFormEncoder(map[string]string{})
		{
			// Encode "flag_log_error_php" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "flag_log_error_php",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := request.FlagLogErrorPhp.Get(); ok {
					return e.EncodeValue(conv.BoolToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		{
			// Encode "flag_log_error_apache" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "flag_log_error_apache",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := request.FlagLogErrorApache.Get(); ok {
					return e.EncodeValue(conv.BoolToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		{
			// Encode "flag_log_access_nginx" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "flag_log_access_nginx",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := request.FlagLogAccessNginx.Get(); ok {
					return e.EncodeValue(conv.BoolToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		{
			// Encode "flag_page_replace_500" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "flag_page_replace_500",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := request.FlagPageReplace500.Get(); ok {
					return e.EncodeValue(conv.BoolToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		{
			// Encode "password" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "password",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := request.Password.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		{
			// Encode "password_hash" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "password_hash",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := request.PasswordHash.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		encoded := q.Values().Encode()
		ht.SetBody(r, strings.NewReader(encoded), contentType)
		return nil
	case *PatchedExternalAsteroidRequestMultipart:
		const contentType = "multipart/form-data"
		request := req

		q := uri.NewFormEncoder(map[string]string{})
		{
			// Encode "flag_log_error_php" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "flag_log_error_php",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := request.FlagLogErrorPhp.Get(); ok {
					return e.EncodeValue(conv.BoolToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		{
			// Encode "flag_log_error_apache" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "flag_log_error_apache",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := request.FlagLogErrorApache.Get(); ok {
					return e.EncodeValue(conv.BoolToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		{
			// Encode "flag_log_access_nginx" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "flag_log_access_nginx",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := request.FlagLogAccessNginx.Get(); ok {
					return e.EncodeValue(conv.BoolToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		{
			// Encode "flag_page_replace_500" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "flag_page_replace_500",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := request.FlagPageReplace500.Get(); ok {
					return e.EncodeValue(conv.BoolToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		{
			// Encode "password" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "password",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := request.Password.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		{
			// Encode "password_hash" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "password_hash",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := request.PasswordHash.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		body, boundary := ht.CreateMultipartBody(func(w *multipart.Writer) error {
			if err := q.WriteMultipart(w); err != nil {
				return errors.Wrap(err, "write multipart")
			}
			return nil
		})
		ht.SetCloserBody(r, body, mime.FormatMediaType(contentType, map[string]string{"boundary": boundary}))
		return nil
	default:
		return errors.Errorf("unexpected request type: %T", req)
	}
}

func encodeAsteroidsSshkeysCreateRequest(
	req AsteroidsSshkeysCreateReq,
	r *http.Request,
) error {
	switch req := req.(type) {
	case *AsteroidsSshkeysCreateApplicationJSON:
		const contentType = "application/json"
		e := new(jx.Encoder)
		{
			req.Encode(e)
		}
		encoded := e.Bytes()
		ht.SetBody(r, bytes.NewReader(encoded), contentType)
		return nil
	case *AsteroidsSshkeysCreateApplicationXWwwFormUrlencoded:
		const contentType = "application/x-www-form-urlencoded"
		request := req

		q := uri.NewFormEncoder(map[string]string{})
		{
			// Encode "key_type" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "key_type",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				return e.EncodeValue(conv.StringToString(string(request.KeyType)))
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		{
			// Encode "key" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "key",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				return e.EncodeValue(conv.StringToString(request.Key))
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		{
			// Encode "key_comment" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "key_comment",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := request.KeyComment.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		{
			// Encode "asteroid" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "asteroid",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				return e.EncodeValue(conv.StringToString(request.Asteroid))
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		encoded := q.Values().Encode()
		ht.SetBody(r, strings.NewReader(encoded), contentType)
		return nil
	case *SshKeyRequestMultipart:
		const contentType = "multipart/form-data"
		request := req

		q := uri.NewFormEncoder(map[string]string{})
		{
			// Encode "key_type" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "key_type",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				return e.EncodeValue(conv.StringToString(string(request.KeyType)))
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		{
			// Encode "key" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "key",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				return e.EncodeValue(conv.StringToString(request.Key))
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		{
			// Encode "key_comment" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "key_comment",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := request.KeyComment.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		{
			// Encode "asteroid" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "asteroid",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				return e.EncodeValue(conv.StringToString(request.Asteroid))
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		body, boundary := ht.CreateMultipartBody(func(w *multipart.Writer) error {
			if err := q.WriteMultipart(w); err != nil {
				return errors.Wrap(err, "write multipart")
			}
			return nil
		})
		ht.SetCloserBody(r, body, mime.FormatMediaType(contentType, map[string]string{"boundary": boundary}))
		return nil
	default:
		return errors.Errorf("unexpected request type: %T", req)
	}
}

func encodeAsteroidsToolversionsPatchRequest(
	req AsteroidsToolversionsPatchReq,
	r *http.Request,
) error {
	switch req := req.(type) {
	case *AsteroidsToolversionsPatchReqEmptyBody:
		// Empty body case.
		return nil
	case *AsteroidsToolversionsPatchApplicationJSON:
		const contentType = "application/json"
		e := new(jx.Encoder)
		{
			req.Encode(e)
		}
		encoded := e.Bytes()
		ht.SetBody(r, bytes.NewReader(encoded), contentType)
		return nil
	case *AsteroidsToolversionsPatchApplicationXWwwFormUrlencoded:
		const contentType = "application/x-www-form-urlencoded"
		request := req

		q := uri.NewFormEncoder(map[string]string{})
		{
			// Encode "version" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "version",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := request.Version.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		encoded := q.Values().Encode()
		ht.SetBody(r, strings.NewReader(encoded), contentType)
		return nil
	case *PatchedSelectedToolVersionRequestMultipart:
		const contentType = "multipart/form-data"
		request := req

		q := uri.NewFormEncoder(map[string]string{})
		{
			// Encode "version" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "version",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := request.Version.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		body, boundary := ht.CreateMultipartBody(func(w *multipart.Writer) error {
			if err := q.WriteMultipart(w); err != nil {
				return errors.Wrap(err, "write multipart")
			}
			return nil
		})
		ht.SetCloserBody(r, body, mime.FormatMediaType(contentType, map[string]string{"boundary": boundary}))
		return nil
	default:
		return errors.Errorf("unexpected request type: %T", req)
	}
}

func encodeAsteroidsWebdomainsBackendsCreateRequest(
	req AsteroidsWebdomainsBackendsCreateReq,
	r *http.Request,
) error {
	switch req := req.(type) {
	case *AsteroidsWebdomainsBackendsCreateApplicationJSON:
		const contentType = "application/json"
		e := new(jx.Encoder)
		{
			req.Encode(e)
		}
		encoded := e.Bytes()
		ht.SetBody(r, bytes.NewReader(encoded), contentType)
		return nil
	case *AsteroidsWebdomainsBackendsCreateApplicationXWwwFormUrlencoded:
		const contentType = "application/x-www-form-urlencoded"
		request := req

		q := uri.NewFormEncoder(map[string]string{})
		{
			// Encode "asteroid" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "asteroid",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				return e.EncodeValue(conv.StringToString(request.Asteroid))
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		{
			// Encode "domain" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "domain",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := request.Domain.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		{
			// Encode "path" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "path",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				return e.EncodeValue(conv.StringToString(request.Path))
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		{
			// Encode "remove_prefix" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "remove_prefix",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := request.RemovePrefix.Get(); ok {
					return e.EncodeValue(conv.BoolToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		{
			// Encode "destination" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "destination",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				return e.EncodeValue(conv.StringToString(string(request.Destination)))
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		{
			// Encode "port" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "port",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := request.Port.Get(); ok {
					return e.EncodeValue(conv.IntToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		encoded := q.Values().Encode()
		ht.SetBody(r, strings.NewReader(encoded), contentType)
		return nil
	case *WebBackendRequestMultipart:
		const contentType = "multipart/form-data"
		request := req

		q := uri.NewFormEncoder(map[string]string{})
		{
			// Encode "asteroid" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "asteroid",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				return e.EncodeValue(conv.StringToString(request.Asteroid))
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		{
			// Encode "domain" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "domain",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := request.Domain.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		{
			// Encode "path" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "path",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				return e.EncodeValue(conv.StringToString(request.Path))
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		{
			// Encode "remove_prefix" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "remove_prefix",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := request.RemovePrefix.Get(); ok {
					return e.EncodeValue(conv.BoolToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		{
			// Encode "destination" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "destination",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				return e.EncodeValue(conv.StringToString(string(request.Destination)))
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		{
			// Encode "port" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "port",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := request.Port.Get(); ok {
					return e.EncodeValue(conv.IntToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		body, boundary := ht.CreateMultipartBody(func(w *multipart.Writer) error {
			if err := q.WriteMultipart(w); err != nil {
				return errors.Wrap(err, "write multipart")
			}
			return nil
		})
		ht.SetCloserBody(r, body, mime.FormatMediaType(contentType, map[string]string{"boundary": boundary}))
		return nil
	default:
		return errors.Errorf("unexpected request type: %T", req)
	}
}

func encodeAsteroidsWebdomainsCreateRequest(
	req AsteroidsWebdomainsCreateReq,
	r *http.Request,
) error {
	switch req := req.(type) {
	case *AsteroidsWebdomainsCreateApplicationJSON:
		const contentType = "application/json"
		e := new(jx.Encoder)
		{
			req.Encode(e)
		}
		encoded := e.Bytes()
		ht.SetBody(r, bytes.NewReader(encoded), contentType)
		return nil
	case *AsteroidsWebdomainsCreateApplicationXWwwFormUrlencoded:
		const contentType = "application/x-www-form-urlencoded"
		request := req

		q := uri.NewFormEncoder(map[string]string{})
		{
			// Encode "name" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "name",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				return e.EncodeValue(conv.StringToString(request.Name))
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		{
			// Encode "asteroid" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "asteroid",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				return e.EncodeValue(conv.StringToString(request.Asteroid))
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		encoded := q.Values().Encode()
		ht.SetBody(r, strings.NewReader(encoded), contentType)
		return nil
	case *WebDomainRequestMultipart:
		const contentType = "multipart/form-data"
		request := req

		q := uri.NewFormEncoder(map[string]string{})
		{
			// Encode "name" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "name",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				return e.EncodeValue(conv.StringToString(request.Name))
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		{
			// Encode "asteroid" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "asteroid",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				return e.EncodeValue(conv.StringToString(request.Asteroid))
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		body, boundary := ht.CreateMultipartBody(func(w *multipart.Writer) error {
			if err := q.WriteMultipart(w); err != nil {
				return errors.Wrap(err, "write multipart")
			}
			return nil
		})
		ht.SetCloserBody(r, body, mime.FormatMediaType(contentType, map[string]string{"boundary": boundary}))
		return nil
	default:
		return errors.Errorf("unexpected request type: %T", req)
	}
}

func encodeAsteroidsWebdomainsHeadersCreateRequest(
	req AsteroidsWebdomainsHeadersCreateReq,
	r *http.Request,
) error {
	switch req := req.(type) {
	case *AsteroidsWebdomainsHeadersCreateApplicationJSON:
		const contentType = "application/json"
		e := new(jx.Encoder)
		{
			req.Encode(e)
		}
		encoded := e.Bytes()
		ht.SetBody(r, bytes.NewReader(encoded), contentType)
		return nil
	case *AsteroidsWebdomainsHeadersCreateApplicationXWwwFormUrlencoded:
		const contentType = "application/x-www-form-urlencoded"
		request := req

		q := uri.NewFormEncoder(map[string]string{})
		{
			// Encode "asteroid" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "asteroid",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				return e.EncodeValue(conv.StringToString(request.Asteroid))
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		{
			// Encode "domain" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "domain",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := request.Domain.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		{
			// Encode "path" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "path",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				return e.EncodeValue(conv.StringToString(request.Path))
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		{
			// Encode "value" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "value",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := request.Value.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		{
			// Encode "name" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "name",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				return e.EncodeValue(conv.StringToString(request.Name))
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		encoded := q.Values().Encode()
		ht.SetBody(r, strings.NewReader(encoded), contentType)
		return nil
	case *WebHeaderRequestMultipart:
		const contentType = "multipart/form-data"
		request := req

		q := uri.NewFormEncoder(map[string]string{})
		{
			// Encode "asteroid" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "asteroid",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				return e.EncodeValue(conv.StringToString(request.Asteroid))
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		{
			// Encode "domain" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "domain",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := request.Domain.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		{
			// Encode "path" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "path",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				return e.EncodeValue(conv.StringToString(request.Path))
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		{
			// Encode "value" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "value",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := request.Value.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		{
			// Encode "name" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "name",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				return e.EncodeValue(conv.StringToString(request.Name))
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		body, boundary := ht.CreateMultipartBody(func(w *multipart.Writer) error {
			if err := q.WriteMultipart(w); err != nil {
				return errors.Wrap(err, "write multipart")
			}
			return nil
		})
		ht.SetCloserBody(r, body, mime.FormatMediaType(contentType, map[string]string{"boundary": boundary}))
		return nil
	default:
		return errors.Errorf("unexpected request type: %T", req)
	}
}

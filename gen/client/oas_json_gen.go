// Code generated by ogen, DO NOT EDIT.

package client

import (
	"math/bits"
	"net/url"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"

	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode encodes CreateAsteroidsMaildomainsApplicationJSON as json.
func (s *CreateAsteroidsMaildomainsApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := (*MailDomainRequest)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateAsteroidsMaildomainsApplicationJSON from json.
func (s *CreateAsteroidsMaildomainsApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateAsteroidsMaildomainsApplicationJSON to nil")
	}
	var unwrapped MailDomainRequest
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateAsteroidsMaildomainsApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateAsteroidsMaildomainsApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateAsteroidsMaildomainsApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateAsteroidsMaildomainsApplicationXWwwFormUrlencoded as json.
func (s *CreateAsteroidsMaildomainsApplicationXWwwFormUrlencoded) Encode(e *jx.Encoder) {
	unwrapped := (*MailDomainRequest)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateAsteroidsMaildomainsApplicationXWwwFormUrlencoded from json.
func (s *CreateAsteroidsMaildomainsApplicationXWwwFormUrlencoded) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateAsteroidsMaildomainsApplicationXWwwFormUrlencoded to nil")
	}
	var unwrapped MailDomainRequest
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateAsteroidsMaildomainsApplicationXWwwFormUrlencoded(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateAsteroidsMaildomainsApplicationXWwwFormUrlencoded) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateAsteroidsMaildomainsApplicationXWwwFormUrlencoded) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateAsteroidsMaildomainsUsersApplicationJSON as json.
func (s *CreateAsteroidsMaildomainsUsersApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := (*MailUserRequest)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateAsteroidsMaildomainsUsersApplicationJSON from json.
func (s *CreateAsteroidsMaildomainsUsersApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateAsteroidsMaildomainsUsersApplicationJSON to nil")
	}
	var unwrapped MailUserRequest
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateAsteroidsMaildomainsUsersApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateAsteroidsMaildomainsUsersApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateAsteroidsMaildomainsUsersApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateAsteroidsMaildomainsUsersApplicationXWwwFormUrlencoded as json.
func (s *CreateAsteroidsMaildomainsUsersApplicationXWwwFormUrlencoded) Encode(e *jx.Encoder) {
	unwrapped := (*MailUserRequest)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateAsteroidsMaildomainsUsersApplicationXWwwFormUrlencoded from json.
func (s *CreateAsteroidsMaildomainsUsersApplicationXWwwFormUrlencoded) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateAsteroidsMaildomainsUsersApplicationXWwwFormUrlencoded to nil")
	}
	var unwrapped MailUserRequest
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateAsteroidsMaildomainsUsersApplicationXWwwFormUrlencoded(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateAsteroidsMaildomainsUsersApplicationXWwwFormUrlencoded) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateAsteroidsMaildomainsUsersApplicationXWwwFormUrlencoded) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateAsteroidsSshkeysApplicationJSON as json.
func (s *CreateAsteroidsSshkeysApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := (*SshKeyRequest)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateAsteroidsSshkeysApplicationJSON from json.
func (s *CreateAsteroidsSshkeysApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateAsteroidsSshkeysApplicationJSON to nil")
	}
	var unwrapped SshKeyRequest
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateAsteroidsSshkeysApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateAsteroidsSshkeysApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateAsteroidsSshkeysApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateAsteroidsSshkeysApplicationXWwwFormUrlencoded as json.
func (s *CreateAsteroidsSshkeysApplicationXWwwFormUrlencoded) Encode(e *jx.Encoder) {
	unwrapped := (*SshKeyRequest)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateAsteroidsSshkeysApplicationXWwwFormUrlencoded from json.
func (s *CreateAsteroidsSshkeysApplicationXWwwFormUrlencoded) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateAsteroidsSshkeysApplicationXWwwFormUrlencoded to nil")
	}
	var unwrapped SshKeyRequest
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateAsteroidsSshkeysApplicationXWwwFormUrlencoded(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateAsteroidsSshkeysApplicationXWwwFormUrlencoded) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateAsteroidsSshkeysApplicationXWwwFormUrlencoded) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateAsteroidsWebdomainsApplicationJSON as json.
func (s *CreateAsteroidsWebdomainsApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := (*WebDomainRequest)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateAsteroidsWebdomainsApplicationJSON from json.
func (s *CreateAsteroidsWebdomainsApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateAsteroidsWebdomainsApplicationJSON to nil")
	}
	var unwrapped WebDomainRequest
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateAsteroidsWebdomainsApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateAsteroidsWebdomainsApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateAsteroidsWebdomainsApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateAsteroidsWebdomainsApplicationXWwwFormUrlencoded as json.
func (s *CreateAsteroidsWebdomainsApplicationXWwwFormUrlencoded) Encode(e *jx.Encoder) {
	unwrapped := (*WebDomainRequest)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateAsteroidsWebdomainsApplicationXWwwFormUrlencoded from json.
func (s *CreateAsteroidsWebdomainsApplicationXWwwFormUrlencoded) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateAsteroidsWebdomainsApplicationXWwwFormUrlencoded to nil")
	}
	var unwrapped WebDomainRequest
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateAsteroidsWebdomainsApplicationXWwwFormUrlencoded(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateAsteroidsWebdomainsApplicationXWwwFormUrlencoded) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateAsteroidsWebdomainsApplicationXWwwFormUrlencoded) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateAsteroidsWebdomainsBackendsApplicationJSON as json.
func (s *CreateAsteroidsWebdomainsBackendsApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := (*WebBackendRequest)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateAsteroidsWebdomainsBackendsApplicationJSON from json.
func (s *CreateAsteroidsWebdomainsBackendsApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateAsteroidsWebdomainsBackendsApplicationJSON to nil")
	}
	var unwrapped WebBackendRequest
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateAsteroidsWebdomainsBackendsApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateAsteroidsWebdomainsBackendsApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateAsteroidsWebdomainsBackendsApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateAsteroidsWebdomainsBackendsApplicationXWwwFormUrlencoded as json.
func (s *CreateAsteroidsWebdomainsBackendsApplicationXWwwFormUrlencoded) Encode(e *jx.Encoder) {
	unwrapped := (*WebBackendRequest)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateAsteroidsWebdomainsBackendsApplicationXWwwFormUrlencoded from json.
func (s *CreateAsteroidsWebdomainsBackendsApplicationXWwwFormUrlencoded) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateAsteroidsWebdomainsBackendsApplicationXWwwFormUrlencoded to nil")
	}
	var unwrapped WebBackendRequest
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateAsteroidsWebdomainsBackendsApplicationXWwwFormUrlencoded(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateAsteroidsWebdomainsBackendsApplicationXWwwFormUrlencoded) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateAsteroidsWebdomainsBackendsApplicationXWwwFormUrlencoded) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateAsteroidsWebdomainsHeadersApplicationJSON as json.
func (s *CreateAsteroidsWebdomainsHeadersApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := (*WebHeaderRequest)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateAsteroidsWebdomainsHeadersApplicationJSON from json.
func (s *CreateAsteroidsWebdomainsHeadersApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateAsteroidsWebdomainsHeadersApplicationJSON to nil")
	}
	var unwrapped WebHeaderRequest
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateAsteroidsWebdomainsHeadersApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateAsteroidsWebdomainsHeadersApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateAsteroidsWebdomainsHeadersApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateAsteroidsWebdomainsHeadersApplicationXWwwFormUrlencoded as json.
func (s *CreateAsteroidsWebdomainsHeadersApplicationXWwwFormUrlencoded) Encode(e *jx.Encoder) {
	unwrapped := (*WebHeaderRequest)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateAsteroidsWebdomainsHeadersApplicationXWwwFormUrlencoded from json.
func (s *CreateAsteroidsWebdomainsHeadersApplicationXWwwFormUrlencoded) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateAsteroidsWebdomainsHeadersApplicationXWwwFormUrlencoded to nil")
	}
	var unwrapped WebHeaderRequest
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateAsteroidsWebdomainsHeadersApplicationXWwwFormUrlencoded(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateAsteroidsWebdomainsHeadersApplicationXWwwFormUrlencoded) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateAsteroidsWebdomainsHeadersApplicationXWwwFormUrlencoded) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DestinationEnum as json.
func (s DestinationEnum) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DestinationEnum from json.
func (s *DestinationEnum) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DestinationEnum to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DestinationEnum(v) {
	case DestinationEnumAPACHE:
		*s = DestinationEnumAPACHE
	case DestinationEnumSTATIC:
		*s = DestinationEnumSTATIC
	case DestinationEnumPORT:
		*s = DestinationEnumPORT
	default:
		*s = DestinationEnum(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DestinationEnum) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DestinationEnum) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DnsStateEnum as json.
func (s DnsStateEnum) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DnsStateEnum from json.
func (s *DnsStateEnum) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DnsStateEnum to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DnsStateEnum(v) {
	case DnsStateEnumVALID:
		*s = DnsStateEnumVALID
	case DnsStateEnumINVALID:
		*s = DnsStateEnumINVALID
	case DnsStateEnumERROR:
		*s = DnsStateEnumERROR
	case DnsStateEnumUNCHECKED:
		*s = DnsStateEnumUNCHECKED
	default:
		*s = DnsStateEnum(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DnsStateEnum) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DnsStateEnum) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExternalAsteroid) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExternalAsteroid) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("active")
		e.Bool(s.Active)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		if s.FlagLogAccessNginx.Set {
			e.FieldStart("flag_log_access_nginx")
			s.FlagLogAccessNginx.Encode(e)
		}
	}
	{
		if s.FlagLogErrorApache.Set {
			e.FieldStart("flag_log_error_apache")
			s.FlagLogErrorApache.Encode(e)
		}
	}
	{
		if s.FlagLogErrorPhp.Set {
			e.FieldStart("flag_log_error_php")
			s.FlagLogErrorPhp.Encode(e)
		}
	}
	{
		if s.FlagPageReplace500.Set {
			e.FieldStart("flag_page_replace_500")
			s.FlagPageReplace500.Encode(e)
		}
	}
	{
		e.FieldStart("host")
		e.Str(s.Host)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.PasswordHash.Set {
			e.FieldStart("password_hash")
			s.PasswordHash.Encode(e)
		}
	}
	{
		e.FieldStart("pk")
		e.Str(s.Pk)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfExternalAsteroid = [11]string{
	0:  "active",
	1:  "created_at",
	2:  "flag_log_access_nginx",
	3:  "flag_log_error_apache",
	4:  "flag_log_error_php",
	5:  "flag_page_replace_500",
	6:  "host",
	7:  "name",
	8:  "password_hash",
	9:  "pk",
	10: "updated_at",
}

// Decode decodes ExternalAsteroid from json.
func (s *ExternalAsteroid) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExternalAsteroid to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "active":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Active = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "flag_log_access_nginx":
			if err := func() error {
				s.FlagLogAccessNginx.Reset()
				if err := s.FlagLogAccessNginx.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"flag_log_access_nginx\"")
			}
		case "flag_log_error_apache":
			if err := func() error {
				s.FlagLogErrorApache.Reset()
				if err := s.FlagLogErrorApache.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"flag_log_error_apache\"")
			}
		case "flag_log_error_php":
			if err := func() error {
				s.FlagLogErrorPhp.Reset()
				if err := s.FlagLogErrorPhp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"flag_log_error_php\"")
			}
		case "flag_page_replace_500":
			if err := func() error {
				s.FlagPageReplace500.Reset()
				if err := s.FlagPageReplace500.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"flag_page_replace_500\"")
			}
		case "host":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Host = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "password_hash":
			if err := func() error {
				s.PasswordHash.Reset()
				if err := s.PasswordHash.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password_hash\"")
			}
		case "pk":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Pk = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pk\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExternalAsteroid")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11000011,
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfExternalAsteroid) {
					name = jsonFieldsNameOfExternalAsteroid[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExternalAsteroid) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExternalAsteroid) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes KeyTypeEnum as json.
func (s KeyTypeEnum) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes KeyTypeEnum from json.
func (s *KeyTypeEnum) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode KeyTypeEnum to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch KeyTypeEnum(v) {
	case KeyTypeEnumSkEcdsaSha2Nistp256OpensshCom:
		*s = KeyTypeEnumSkEcdsaSha2Nistp256OpensshCom
	case KeyTypeEnumEcdsaSha2Nistp256:
		*s = KeyTypeEnumEcdsaSha2Nistp256
	case KeyTypeEnumEcdsaSha2Nistp384:
		*s = KeyTypeEnumEcdsaSha2Nistp384
	case KeyTypeEnumEcdsaSha2Nistp521:
		*s = KeyTypeEnumEcdsaSha2Nistp521
	case KeyTypeEnumSkSSHEd25519OpensshCom:
		*s = KeyTypeEnumSkSSHEd25519OpensshCom
	case KeyTypeEnumSSHEd25519:
		*s = KeyTypeEnumSSHEd25519
	case KeyTypeEnumSSHRsa:
		*s = KeyTypeEnumSSHRsa
	default:
		*s = KeyTypeEnum(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s KeyTypeEnum) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *KeyTypeEnum) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MailDomain) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MailDomain) encodeFields(e *jx.Encoder) {
	{
		if s.Alias != nil {
			e.FieldStart("alias")
			s.Alias.Encode(e)
		}
	}
	{
		e.FieldStart("asteroid")
		e.Str(s.Asteroid)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("dns_error")
		s.DNSError.Encode(e)
	}
	{
		e.FieldStart("dns_last_check")
		s.DNSLastCheck.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("dns_state")
		s.DNSState.Encode(e)
	}
	{
		e.FieldStart("domain")
		e.Str(s.Domain)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfMailDomain = [8]string{
	0: "alias",
	1: "asteroid",
	2: "created_at",
	3: "dns_error",
	4: "dns_last_check",
	5: "dns_state",
	6: "domain",
	7: "updated_at",
}

// Decode decodes MailDomain from json.
func (s *MailDomain) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MailDomain to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "alias":
			if err := func() error {
				s.Alias = nil
				var elem RelatedMailDomainField
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Alias = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alias\"")
			}
		case "asteroid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Asteroid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"asteroid\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "dns_error":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.DNSError.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dns_error\"")
			}
		case "dns_last_check":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.DNSLastCheck.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dns_last_check\"")
			}
		case "dns_state":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.DNSState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dns_state\"")
			}
		case "domain":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Domain = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domain\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MailDomain")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMailDomain) {
					name = jsonFieldsNameOfMailDomain[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MailDomain) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MailDomain) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MailDomainRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MailDomainRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Alias.Set {
			e.FieldStart("alias")
			s.Alias.Encode(e)
		}
	}
	{
		e.FieldStart("asteroid")
		e.Str(s.Asteroid)
	}
	{
		e.FieldStart("domain")
		e.Str(s.Domain)
	}
}

var jsonFieldsNameOfMailDomainRequest = [3]string{
	0: "alias",
	1: "asteroid",
	2: "domain",
}

// Decode decodes MailDomainRequest from json.
func (s *MailDomainRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MailDomainRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "alias":
			if err := func() error {
				s.Alias.Reset()
				if err := s.Alias.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alias\"")
			}
		case "asteroid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Asteroid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"asteroid\"")
			}
		case "domain":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Domain = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domain\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MailDomainRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMailDomainRequest) {
					name = jsonFieldsNameOfMailDomainRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MailDomainRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MailDomainRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MailUser) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MailUser) encodeFields(e *jx.Encoder) {
	{
		if s.Alias.Set {
			e.FieldStart("alias")
			s.Alias.Encode(e)
		}
	}
	{
		e.FieldStart("asteroid")
		e.Str(s.Asteroid)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		if s.Domain != nil {
			e.FieldStart("domain")
			s.Domain.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.PasswordHash.Set {
			e.FieldStart("password_hash")
			s.PasswordHash.Encode(e)
		}
	}
	{
		e.FieldStart("pk")
		e.Str(s.Pk)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfMailUser = [8]string{
	0: "alias",
	1: "asteroid",
	2: "created_at",
	3: "domain",
	4: "name",
	5: "password_hash",
	6: "pk",
	7: "updated_at",
}

// Decode decodes MailUser from json.
func (s *MailUser) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MailUser to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "alias":
			if err := func() error {
				s.Alias.Reset()
				if err := s.Alias.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alias\"")
			}
		case "asteroid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Asteroid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"asteroid\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "domain":
			if err := func() error {
				s.Domain = nil
				var elem RelatedMailDomainField
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Domain = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domain\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "password_hash":
			if err := func() error {
				s.PasswordHash.Reset()
				if err := s.PasswordHash.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password_hash\"")
			}
		case "pk":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Pk = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pk\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MailUser")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11010110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMailUser) {
					name = jsonFieldsNameOfMailUser[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MailUser) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MailUser) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MailUserRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MailUserRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Alias.Set {
			e.FieldStart("alias")
			s.Alias.Encode(e)
		}
	}
	{
		if s.Domain.Set {
			e.FieldStart("domain")
			s.Domain.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.PasswordHash.Set {
			e.FieldStart("password_hash")
			s.PasswordHash.Encode(e)
		}
	}
}

var jsonFieldsNameOfMailUserRequest = [4]string{
	0: "alias",
	1: "domain",
	2: "name",
	3: "password_hash",
}

// Decode decodes MailUserRequest from json.
func (s *MailUserRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MailUserRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "alias":
			if err := func() error {
				s.Alias.Reset()
				if err := s.Alias.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alias\"")
			}
		case "domain":
			if err := func() error {
				s.Domain.Reset()
				if err := s.Domain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domain\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "password_hash":
			if err := func() error {
				s.PasswordHash.Reset()
				if err := s.PasswordHash.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password_hash\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MailUserRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMailUserRequest) {
					name = jsonFieldsNameOfMailUserRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MailUserRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MailUserRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o NilDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if o.Null {
		e.Null()
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *NilDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilDateTime to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v time.Time
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes string as json.
func (o NilString) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *NilString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilString to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v string
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptNilInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptNilInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilInt to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v int
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptNilString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptNilString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilString to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v string
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes url.URL as json.
func (o OptNilURI) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	json.EncodeURI(e, o.Value)
}

// Decode decodes url.URL from json.
func (o *OptNilURI) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilURI to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v url.URL
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := json.DecodeURI(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilURI) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilURI) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RelatedMailDomainField as json.
func (o OptRelatedMailDomainField) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RelatedMailDomainField from json.
func (o *OptRelatedMailDomainField) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRelatedMailDomainField to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRelatedMailDomainField) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRelatedMailDomainField) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RelatedMailDomainFieldRequest as json.
func (o OptRelatedMailDomainFieldRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RelatedMailDomainFieldRequest from json.
func (o *OptRelatedMailDomainFieldRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRelatedMailDomainFieldRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRelatedMailDomainFieldRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRelatedMailDomainFieldRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RelatedMailUserField as json.
func (o OptRelatedMailUserField) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RelatedMailUserField from json.
func (o *OptRelatedMailUserField) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRelatedMailUserField to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRelatedMailUserField) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRelatedMailUserField) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RelatedMailUserFieldRequest as json.
func (o OptRelatedMailUserFieldRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RelatedMailUserFieldRequest from json.
func (o *OptRelatedMailUserFieldRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRelatedMailUserFieldRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRelatedMailUserFieldRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRelatedMailUserFieldRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PaginatedMailDomainList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PaginatedMailDomainList) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("count")
		e.Int(s.Count)
	}
	{
		if s.Next.Set {
			e.FieldStart("next")
			s.Next.Encode(e)
		}
	}
	{
		if s.Previous.Set {
			e.FieldStart("previous")
			s.Previous.Encode(e)
		}
	}
	{
		e.FieldStart("results")
		e.ArrStart()
		for _, elem := range s.Results {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfPaginatedMailDomainList = [4]string{
	0: "count",
	1: "next",
	2: "previous",
	3: "results",
}

// Decode decodes PaginatedMailDomainList from json.
func (s *PaginatedMailDomainList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PaginatedMailDomainList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Count = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"count\"")
			}
		case "next":
			if err := func() error {
				s.Next.Reset()
				if err := s.Next.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next\"")
			}
		case "previous":
			if err := func() error {
				s.Previous.Reset()
				if err := s.Previous.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"previous\"")
			}
		case "results":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Results = make([]MailDomain, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MailDomain
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Results = append(s.Results, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"results\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PaginatedMailDomainList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPaginatedMailDomainList) {
					name = jsonFieldsNameOfPaginatedMailDomainList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PaginatedMailDomainList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PaginatedMailDomainList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PaginatedMailUserList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PaginatedMailUserList) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("count")
		e.Int(s.Count)
	}
	{
		if s.Next.Set {
			e.FieldStart("next")
			s.Next.Encode(e)
		}
	}
	{
		if s.Previous.Set {
			e.FieldStart("previous")
			s.Previous.Encode(e)
		}
	}
	{
		e.FieldStart("results")
		e.ArrStart()
		for _, elem := range s.Results {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfPaginatedMailUserList = [4]string{
	0: "count",
	1: "next",
	2: "previous",
	3: "results",
}

// Decode decodes PaginatedMailUserList from json.
func (s *PaginatedMailUserList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PaginatedMailUserList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Count = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"count\"")
			}
		case "next":
			if err := func() error {
				s.Next.Reset()
				if err := s.Next.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next\"")
			}
		case "previous":
			if err := func() error {
				s.Previous.Reset()
				if err := s.Previous.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"previous\"")
			}
		case "results":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Results = make([]MailUser, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MailUser
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Results = append(s.Results, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"results\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PaginatedMailUserList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPaginatedMailUserList) {
					name = jsonFieldsNameOfPaginatedMailUserList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PaginatedMailUserList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PaginatedMailUserList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PaginatedSshKeyList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PaginatedSshKeyList) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("count")
		e.Int(s.Count)
	}
	{
		if s.Next.Set {
			e.FieldStart("next")
			s.Next.Encode(e)
		}
	}
	{
		if s.Previous.Set {
			e.FieldStart("previous")
			s.Previous.Encode(e)
		}
	}
	{
		e.FieldStart("results")
		e.ArrStart()
		for _, elem := range s.Results {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfPaginatedSshKeyList = [4]string{
	0: "count",
	1: "next",
	2: "previous",
	3: "results",
}

// Decode decodes PaginatedSshKeyList from json.
func (s *PaginatedSshKeyList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PaginatedSshKeyList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Count = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"count\"")
			}
		case "next":
			if err := func() error {
				s.Next.Reset()
				if err := s.Next.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next\"")
			}
		case "previous":
			if err := func() error {
				s.Previous.Reset()
				if err := s.Previous.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"previous\"")
			}
		case "results":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Results = make([]SshKey, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SshKey
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Results = append(s.Results, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"results\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PaginatedSshKeyList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPaginatedSshKeyList) {
					name = jsonFieldsNameOfPaginatedSshKeyList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PaginatedSshKeyList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PaginatedSshKeyList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PaginatedWebBackendList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PaginatedWebBackendList) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("count")
		e.Int(s.Count)
	}
	{
		if s.Next.Set {
			e.FieldStart("next")
			s.Next.Encode(e)
		}
	}
	{
		if s.Previous.Set {
			e.FieldStart("previous")
			s.Previous.Encode(e)
		}
	}
	{
		e.FieldStart("results")
		e.ArrStart()
		for _, elem := range s.Results {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfPaginatedWebBackendList = [4]string{
	0: "count",
	1: "next",
	2: "previous",
	3: "results",
}

// Decode decodes PaginatedWebBackendList from json.
func (s *PaginatedWebBackendList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PaginatedWebBackendList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Count = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"count\"")
			}
		case "next":
			if err := func() error {
				s.Next.Reset()
				if err := s.Next.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next\"")
			}
		case "previous":
			if err := func() error {
				s.Previous.Reset()
				if err := s.Previous.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"previous\"")
			}
		case "results":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Results = make([]WebBackend, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem WebBackend
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Results = append(s.Results, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"results\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PaginatedWebBackendList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPaginatedWebBackendList) {
					name = jsonFieldsNameOfPaginatedWebBackendList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PaginatedWebBackendList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PaginatedWebBackendList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PaginatedWebDomainList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PaginatedWebDomainList) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("count")
		e.Int(s.Count)
	}
	{
		if s.Next.Set {
			e.FieldStart("next")
			s.Next.Encode(e)
		}
	}
	{
		if s.Previous.Set {
			e.FieldStart("previous")
			s.Previous.Encode(e)
		}
	}
	{
		e.FieldStart("results")
		e.ArrStart()
		for _, elem := range s.Results {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfPaginatedWebDomainList = [4]string{
	0: "count",
	1: "next",
	2: "previous",
	3: "results",
}

// Decode decodes PaginatedWebDomainList from json.
func (s *PaginatedWebDomainList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PaginatedWebDomainList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Count = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"count\"")
			}
		case "next":
			if err := func() error {
				s.Next.Reset()
				if err := s.Next.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next\"")
			}
		case "previous":
			if err := func() error {
				s.Previous.Reset()
				if err := s.Previous.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"previous\"")
			}
		case "results":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Results = make([]WebDomain, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem WebDomain
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Results = append(s.Results, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"results\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PaginatedWebDomainList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPaginatedWebDomainList) {
					name = jsonFieldsNameOfPaginatedWebDomainList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PaginatedWebDomainList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PaginatedWebDomainList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PaginatedWebHeaderList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PaginatedWebHeaderList) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("count")
		e.Int(s.Count)
	}
	{
		if s.Next.Set {
			e.FieldStart("next")
			s.Next.Encode(e)
		}
	}
	{
		if s.Previous.Set {
			e.FieldStart("previous")
			s.Previous.Encode(e)
		}
	}
	{
		e.FieldStart("results")
		e.ArrStart()
		for _, elem := range s.Results {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfPaginatedWebHeaderList = [4]string{
	0: "count",
	1: "next",
	2: "previous",
	3: "results",
}

// Decode decodes PaginatedWebHeaderList from json.
func (s *PaginatedWebHeaderList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PaginatedWebHeaderList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Count = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"count\"")
			}
		case "next":
			if err := func() error {
				s.Next.Reset()
				if err := s.Next.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next\"")
			}
		case "previous":
			if err := func() error {
				s.Previous.Reset()
				if err := s.Previous.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"previous\"")
			}
		case "results":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Results = make([]WebHeader, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem WebHeader
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Results = append(s.Results, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"results\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PaginatedWebHeaderList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPaginatedWebHeaderList) {
					name = jsonFieldsNameOfPaginatedWebHeaderList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PaginatedWebHeaderList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PaginatedWebHeaderList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PatchAsteroidApplicationJSON as json.
func (s *PatchAsteroidApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := (*PatchedExternalAsteroidRequest)(s)

	unwrapped.Encode(e)
}

// Decode decodes PatchAsteroidApplicationJSON from json.
func (s *PatchAsteroidApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PatchAsteroidApplicationJSON to nil")
	}
	var unwrapped PatchedExternalAsteroidRequest
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PatchAsteroidApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PatchAsteroidApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PatchAsteroidApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PatchAsteroidApplicationXWwwFormUrlencoded as json.
func (s *PatchAsteroidApplicationXWwwFormUrlencoded) Encode(e *jx.Encoder) {
	unwrapped := (*PatchedExternalAsteroidRequest)(s)

	unwrapped.Encode(e)
}

// Decode decodes PatchAsteroidApplicationXWwwFormUrlencoded from json.
func (s *PatchAsteroidApplicationXWwwFormUrlencoded) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PatchAsteroidApplicationXWwwFormUrlencoded to nil")
	}
	var unwrapped PatchedExternalAsteroidRequest
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PatchAsteroidApplicationXWwwFormUrlencoded(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PatchAsteroidApplicationXWwwFormUrlencoded) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PatchAsteroidApplicationXWwwFormUrlencoded) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PatchAsteroidMaildomainUserApplicationJSON as json.
func (s *PatchAsteroidMaildomainUserApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := (*PatchedMailUserRequest)(s)

	unwrapped.Encode(e)
}

// Decode decodes PatchAsteroidMaildomainUserApplicationJSON from json.
func (s *PatchAsteroidMaildomainUserApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PatchAsteroidMaildomainUserApplicationJSON to nil")
	}
	var unwrapped PatchedMailUserRequest
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PatchAsteroidMaildomainUserApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PatchAsteroidMaildomainUserApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PatchAsteroidMaildomainUserApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PatchAsteroidMaildomainUserApplicationXWwwFormUrlencoded as json.
func (s *PatchAsteroidMaildomainUserApplicationXWwwFormUrlencoded) Encode(e *jx.Encoder) {
	unwrapped := (*PatchedMailUserRequest)(s)

	unwrapped.Encode(e)
}

// Decode decodes PatchAsteroidMaildomainUserApplicationXWwwFormUrlencoded from json.
func (s *PatchAsteroidMaildomainUserApplicationXWwwFormUrlencoded) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PatchAsteroidMaildomainUserApplicationXWwwFormUrlencoded to nil")
	}
	var unwrapped PatchedMailUserRequest
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PatchAsteroidMaildomainUserApplicationXWwwFormUrlencoded(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PatchAsteroidMaildomainUserApplicationXWwwFormUrlencoded) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PatchAsteroidMaildomainUserApplicationXWwwFormUrlencoded) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PatchedExternalAsteroidRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PatchedExternalAsteroidRequest) encodeFields(e *jx.Encoder) {
	{
		if s.FlagLogAccessNginx.Set {
			e.FieldStart("flag_log_access_nginx")
			s.FlagLogAccessNginx.Encode(e)
		}
	}
	{
		if s.FlagLogErrorApache.Set {
			e.FieldStart("flag_log_error_apache")
			s.FlagLogErrorApache.Encode(e)
		}
	}
	{
		if s.FlagLogErrorPhp.Set {
			e.FieldStart("flag_log_error_php")
			s.FlagLogErrorPhp.Encode(e)
		}
	}
	{
		if s.FlagPageReplace500.Set {
			e.FieldStart("flag_page_replace_500")
			s.FlagPageReplace500.Encode(e)
		}
	}
	{
		if s.Password.Set {
			e.FieldStart("password")
			s.Password.Encode(e)
		}
	}
	{
		if s.PasswordHash.Set {
			e.FieldStart("password_hash")
			s.PasswordHash.Encode(e)
		}
	}
}

var jsonFieldsNameOfPatchedExternalAsteroidRequest = [6]string{
	0: "flag_log_access_nginx",
	1: "flag_log_error_apache",
	2: "flag_log_error_php",
	3: "flag_page_replace_500",
	4: "password",
	5: "password_hash",
}

// Decode decodes PatchedExternalAsteroidRequest from json.
func (s *PatchedExternalAsteroidRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PatchedExternalAsteroidRequest to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "flag_log_access_nginx":
			if err := func() error {
				s.FlagLogAccessNginx.Reset()
				if err := s.FlagLogAccessNginx.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"flag_log_access_nginx\"")
			}
		case "flag_log_error_apache":
			if err := func() error {
				s.FlagLogErrorApache.Reset()
				if err := s.FlagLogErrorApache.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"flag_log_error_apache\"")
			}
		case "flag_log_error_php":
			if err := func() error {
				s.FlagLogErrorPhp.Reset()
				if err := s.FlagLogErrorPhp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"flag_log_error_php\"")
			}
		case "flag_page_replace_500":
			if err := func() error {
				s.FlagPageReplace500.Reset()
				if err := s.FlagPageReplace500.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"flag_page_replace_500\"")
			}
		case "password":
			if err := func() error {
				s.Password.Reset()
				if err := s.Password.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		case "password_hash":
			if err := func() error {
				s.PasswordHash.Reset()
				if err := s.PasswordHash.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password_hash\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PatchedExternalAsteroidRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PatchedExternalAsteroidRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PatchedExternalAsteroidRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PatchedMailUserRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PatchedMailUserRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Alias.Set {
			e.FieldStart("alias")
			s.Alias.Encode(e)
		}
	}
	{
		if s.PasswordHash.Set {
			e.FieldStart("password_hash")
			s.PasswordHash.Encode(e)
		}
	}
}

var jsonFieldsNameOfPatchedMailUserRequest = [2]string{
	0: "alias",
	1: "password_hash",
}

// Decode decodes PatchedMailUserRequest from json.
func (s *PatchedMailUserRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PatchedMailUserRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "alias":
			if err := func() error {
				s.Alias.Reset()
				if err := s.Alias.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alias\"")
			}
		case "password_hash":
			if err := func() error {
				s.PasswordHash.Reset()
				if err := s.PasswordHash.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password_hash\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PatchedMailUserRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PatchedMailUserRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PatchedMailUserRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RelatedMailDomainField) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RelatedMailDomainField) encodeFields(e *jx.Encoder) {
	{
		if s.Alias.Set {
			e.FieldStart("alias")
			s.Alias.Encode(e)
		}
	}
	{
		e.FieldStart("asteroid")
		e.Str(s.Asteroid)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		if s.Domain != nil {
			e.FieldStart("domain")
			s.Domain.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.PasswordHash.Set {
			e.FieldStart("password_hash")
			s.PasswordHash.Encode(e)
		}
	}
	{
		e.FieldStart("pk")
		e.Str(s.Pk)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfRelatedMailDomainField = [8]string{
	0: "alias",
	1: "asteroid",
	2: "created_at",
	3: "domain",
	4: "name",
	5: "password_hash",
	6: "pk",
	7: "updated_at",
}

// Decode decodes RelatedMailDomainField from json.
func (s *RelatedMailDomainField) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RelatedMailDomainField to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "alias":
			if err := func() error {
				s.Alias.Reset()
				if err := s.Alias.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alias\"")
			}
		case "asteroid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Asteroid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"asteroid\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "domain":
			if err := func() error {
				s.Domain = nil
				var elem RelatedMailDomainField
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Domain = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domain\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "password_hash":
			if err := func() error {
				s.PasswordHash.Reset()
				if err := s.PasswordHash.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password_hash\"")
			}
		case "pk":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Pk = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pk\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RelatedMailDomainField")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11010110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRelatedMailDomainField) {
					name = jsonFieldsNameOfRelatedMailDomainField[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RelatedMailDomainField) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RelatedMailDomainField) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RelatedMailDomainFieldRequest as json.
func (s RelatedMailDomainFieldRequest) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes RelatedMailDomainFieldRequest from json.
func (s *RelatedMailDomainFieldRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RelatedMailDomainFieldRequest to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RelatedMailDomainFieldRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RelatedMailDomainFieldRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RelatedMailDomainFieldRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RelatedMailUserField) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RelatedMailUserField) encodeFields(e *jx.Encoder) {
	{
		if s.Alias != nil {
			e.FieldStart("alias")
			s.Alias.Encode(e)
		}
	}
	{
		e.FieldStart("asteroid")
		e.Str(s.Asteroid)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		if s.Domain != nil {
			e.FieldStart("domain")
			s.Domain.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.PasswordHash.Set {
			e.FieldStart("password_hash")
			s.PasswordHash.Encode(e)
		}
	}
	{
		e.FieldStart("pk")
		e.Str(s.Pk)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfRelatedMailUserField = [8]string{
	0: "alias",
	1: "asteroid",
	2: "created_at",
	3: "domain",
	4: "name",
	5: "password_hash",
	6: "pk",
	7: "updated_at",
}

// Decode decodes RelatedMailUserField from json.
func (s *RelatedMailUserField) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RelatedMailUserField to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "alias":
			if err := func() error {
				s.Alias = nil
				var elem RelatedMailUserField
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Alias = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alias\"")
			}
		case "asteroid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Asteroid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"asteroid\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "domain":
			if err := func() error {
				s.Domain = nil
				var elem RelatedMailDomainField
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Domain = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domain\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "password_hash":
			if err := func() error {
				s.PasswordHash.Reset()
				if err := s.PasswordHash.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password_hash\"")
			}
		case "pk":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Pk = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pk\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RelatedMailUserField")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11010110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRelatedMailUserField) {
					name = jsonFieldsNameOfRelatedMailUserField[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RelatedMailUserField) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RelatedMailUserField) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RelatedMailUserFieldRequest as json.
func (s RelatedMailUserFieldRequest) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes RelatedMailUserFieldRequest from json.
func (s *RelatedMailUserFieldRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RelatedMailUserFieldRequest to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RelatedMailUserFieldRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RelatedMailUserFieldRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RelatedMailUserFieldRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SshKey) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SshKey) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("asteroid")
		e.Str(s.Asteroid)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("formatted_key")
		e.Str(s.FormattedKey)
	}
	{
		e.FieldStart("key")
		e.Str(s.Key)
	}
	{
		if s.KeyComment.Set {
			e.FieldStart("key_comment")
			s.KeyComment.Encode(e)
		}
	}
	{
		e.FieldStart("key_type")
		s.KeyType.Encode(e)
	}
	{
		e.FieldStart("pk")
		e.Int(s.Pk)
	}
	{
		e.FieldStart("shortened_key")
		e.Str(s.ShortenedKey)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfSshKey = [9]string{
	0: "asteroid",
	1: "created_at",
	2: "formatted_key",
	3: "key",
	4: "key_comment",
	5: "key_type",
	6: "pk",
	7: "shortened_key",
	8: "updated_at",
}

// Decode decodes SshKey from json.
func (s *SshKey) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SshKey to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "asteroid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Asteroid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"asteroid\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "formatted_key":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.FormattedKey = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"formatted_key\"")
			}
		case "key":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "key_comment":
			if err := func() error {
				s.KeyComment.Reset()
				if err := s.KeyComment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key_comment\"")
			}
		case "key_type":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.KeyType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key_type\"")
			}
		case "pk":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Pk = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pk\"")
			}
		case "shortened_key":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.ShortenedKey = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shortened_key\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SshKey")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11101111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSshKey) {
					name = jsonFieldsNameOfSshKey[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SshKey) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SshKey) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SshKeyRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SshKeyRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("asteroid")
		e.Str(s.Asteroid)
	}
	{
		e.FieldStart("key")
		e.Str(s.Key)
	}
	{
		if s.KeyComment.Set {
			e.FieldStart("key_comment")
			s.KeyComment.Encode(e)
		}
	}
	{
		e.FieldStart("key_type")
		s.KeyType.Encode(e)
	}
}

var jsonFieldsNameOfSshKeyRequest = [4]string{
	0: "asteroid",
	1: "key",
	2: "key_comment",
	3: "key_type",
}

// Decode decodes SshKeyRequest from json.
func (s *SshKeyRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SshKeyRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "asteroid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Asteroid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"asteroid\"")
			}
		case "key":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "key_comment":
			if err := func() error {
				s.KeyComment.Reset()
				if err := s.KeyComment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key_comment\"")
			}
		case "key_type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.KeyType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key_type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SshKeyRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSshKeyRequest) {
					name = jsonFieldsNameOfSshKeyRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SshKeyRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SshKeyRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WebBackend) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WebBackend) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("asteroid")
		e.Str(s.Asteroid)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("destination")
		s.Destination.Encode(e)
	}
	{
		e.FieldStart("domain")
		s.Domain.Encode(e)
	}
	{
		e.FieldStart("path")
		e.Str(s.Path)
	}
	{
		e.FieldStart("pk")
		e.Int(s.Pk)
	}
	{
		if s.Port.Set {
			e.FieldStart("port")
			s.Port.Encode(e)
		}
	}
	{
		if s.RemovePrefix.Set {
			e.FieldStart("remove_prefix")
			s.RemovePrefix.Encode(e)
		}
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfWebBackend = [9]string{
	0: "asteroid",
	1: "created_at",
	2: "destination",
	3: "domain",
	4: "path",
	5: "pk",
	6: "port",
	7: "remove_prefix",
	8: "updated_at",
}

// Decode decodes WebBackend from json.
func (s *WebBackend) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebBackend to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "asteroid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Asteroid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"asteroid\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "destination":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Destination.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"destination\"")
			}
		case "domain":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Domain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domain\"")
			}
		case "path":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Path = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "pk":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Pk = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pk\"")
			}
		case "port":
			if err := func() error {
				s.Port.Reset()
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "remove_prefix":
			if err := func() error {
				s.RemovePrefix.Reset()
				if err := s.RemovePrefix.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remove_prefix\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WebBackend")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00111111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWebBackend) {
					name = jsonFieldsNameOfWebBackend[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WebBackend) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebBackend) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WebBackendRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WebBackendRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("asteroid")
		e.Str(s.Asteroid)
	}
	{
		e.FieldStart("destination")
		s.Destination.Encode(e)
	}
	{
		e.FieldStart("domain")
		s.Domain.Encode(e)
	}
	{
		e.FieldStart("path")
		e.Str(s.Path)
	}
	{
		if s.Port.Set {
			e.FieldStart("port")
			s.Port.Encode(e)
		}
	}
	{
		if s.RemovePrefix.Set {
			e.FieldStart("remove_prefix")
			s.RemovePrefix.Encode(e)
		}
	}
}

var jsonFieldsNameOfWebBackendRequest = [6]string{
	0: "asteroid",
	1: "destination",
	2: "domain",
	3: "path",
	4: "port",
	5: "remove_prefix",
}

// Decode decodes WebBackendRequest from json.
func (s *WebBackendRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebBackendRequest to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "asteroid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Asteroid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"asteroid\"")
			}
		case "destination":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Destination.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"destination\"")
			}
		case "domain":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Domain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domain\"")
			}
		case "path":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Path = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "port":
			if err := func() error {
				s.Port.Reset()
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "remove_prefix":
			if err := func() error {
				s.RemovePrefix.Reset()
				if err := s.RemovePrefix.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remove_prefix\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WebBackendRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWebBackendRequest) {
					name = jsonFieldsNameOfWebBackendRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WebBackendRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebBackendRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WebDomain) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WebDomain) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("asteroid")
		e.Str(s.Asteroid)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("domain")
		e.Str(s.Domain)
	}
	{
		e.FieldStart("domain_idn")
		e.Str(s.DomainIdn)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfWebDomain = [5]string{
	0: "asteroid",
	1: "created_at",
	2: "domain",
	3: "domain_idn",
	4: "updated_at",
}

// Decode decodes WebDomain from json.
func (s *WebDomain) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebDomain to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "asteroid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Asteroid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"asteroid\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "domain":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Domain = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domain\"")
			}
		case "domain_idn":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.DomainIdn = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domain_idn\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WebDomain")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWebDomain) {
					name = jsonFieldsNameOfWebDomain[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WebDomain) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebDomain) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WebDomainRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WebDomainRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("asteroid")
		e.Str(s.Asteroid)
	}
	{
		e.FieldStart("domain")
		e.Str(s.Domain)
	}
}

var jsonFieldsNameOfWebDomainRequest = [2]string{
	0: "asteroid",
	1: "domain",
}

// Decode decodes WebDomainRequest from json.
func (s *WebDomainRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebDomainRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "asteroid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Asteroid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"asteroid\"")
			}
		case "domain":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Domain = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domain\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WebDomainRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWebDomainRequest) {
					name = jsonFieldsNameOfWebDomainRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WebDomainRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebDomainRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WebHeader) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WebHeader) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("asteroid")
		e.Str(s.Asteroid)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("domain")
		s.Domain.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("path")
		e.Str(s.Path)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
}

var jsonFieldsNameOfWebHeader = [7]string{
	0: "asteroid",
	1: "created_at",
	2: "domain",
	3: "name",
	4: "path",
	5: "updated_at",
	6: "value",
}

// Decode decodes WebHeader from json.
func (s *WebHeader) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebHeader to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "asteroid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Asteroid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"asteroid\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "domain":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Domain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domain\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "path":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Path = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WebHeader")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWebHeader) {
					name = jsonFieldsNameOfWebHeader[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WebHeader) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebHeader) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WebHeaderRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WebHeaderRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("asteroid")
		e.Str(s.Asteroid)
	}
	{
		e.FieldStart("domain")
		s.Domain.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("path")
		e.Str(s.Path)
	}
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
}

var jsonFieldsNameOfWebHeaderRequest = [5]string{
	0: "asteroid",
	1: "domain",
	2: "name",
	3: "path",
	4: "value",
}

// Decode decodes WebHeaderRequest from json.
func (s *WebHeaderRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebHeaderRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "asteroid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Asteroid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"asteroid\"")
			}
		case "domain":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Domain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domain\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "path":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Path = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WebHeaderRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWebHeaderRequest) {
					name = jsonFieldsNameOfWebHeaderRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WebHeaderRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebHeaderRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
